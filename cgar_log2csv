#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
cgar_log2csv

Reads `cgar_collect` log and prints data as CSV to stdout.


If new controllers or controllerfiles need to be added:
------------------------------------------------------

1. Extend global dictionary `ATTRIBUTE_MAP`.

2. Add support for the controller file in `convert()`


Ideas:
------
    - Be more flexible with date and time.
    - Add converters (Byte to KiB, etc.).
    - Support wildcards to easily select children (e.g. 'system.slice/*' or 'system.slice/*.service')
    - Check if the tool can handle logs where the content (added/removed cgroups/controllers) has changed.


Changelog:
----------
    05.02.2023      v0.1beta        - first bits are done
    05.02.2023      v0.2            - fixed bug where complex attributes (like `memory.pressure`)
                                      have not been resolved
                                    - introduced global cgroup attribute mapping for easier extensibility
                                    - fixed classic BrokenPipeError error
                                    - dared to remove beta status
"""

import argparse
import datetime
import json
import os
import re
import sys
from pprint import pprint

__version__ = '0.2'

# This map must have listed each supported cgroup controller as key and as value a dictionary
# with supported controller files as key and the output representation (column) as value.
# Most of the time this will be a one to one mapping, but some complex files contain multiple
# entries and shall be separated into individual columns.
# The `convert()` function must return the resolved columns!
ATTRIBUTE_MAP = {'memory': {'memory.current': ['memory.current'], 
                            'memory.swap.current': ['memory.swap.current'], 
                            'memory.pressure' : ['memory.pressure::some_avg10', 
                                                 'memory.pressure::some_avg60',
                                                 'memory.pressure::some_avg300', 
                                                 'memory.pressure::some_total',
                                                 'memory.pressure::full_avg10',
                                                 'memory.pressure::full_avg60',
                                                 'memory.pressure::full_avg300',
                                                 'memory.pressure::full_total']
                           }
                }


def argument_parse():
    """Evaluates the command line arguments."""

    supported = {k: set(v.keys()) for (k, v) in ATTRIBUTE_MAP.items()}

    parser = argparse. ArgumentParser(prog=os.path.basename(sys.argv[0]), 
                       description='Extracts cgroup data from cgar collector log and prints them as CSV on stdout.',
                       add_help=True,
                       epilog=f'v{__version__}')

    # Global flags and arguments.   
    parser.add_argument('--start-time',
                        metavar='TIME',
                        dest='start_time',
                        type=str,
                        action='store',
                        required=False,
                        help='only print data from this time forward (no timezone info)')   
    parser.add_argument('--end-time',
                        metavar='TIME',
                        dest='end_time',
                        type=str,
                        action='store',
                        required=False,
                        help='only print data to this time (no timezone info)')
    parser.add_argument('-l', '--log',
                        dest='logfile',
                        type=str,
                        action='store',
                        required=False,
                        default='/var/log/cgar/cgar',
                        help='logfile to parse (default: "/var/log/cgar/cgar")')    
    parser.add_argument('-f', '--filter',
                        dest='filter',
                        type=str,
                        action='append',
                        required=False,
                        help='use only these controller attributes')  
    parser.add_argument('-s', '--separator',
                        dest='separator',
                        type=str,
                        action='store',
                        default=',',
                        required=False,
                        help='separator for the output (default: ,')  
    parser.add_argument('--quote-strings',
                        dest='quotestrings',
                        action='store_true',
                        default=False,
                        required=False,
                        help='if strings in CSV output shall be quoted (default: false')
    parser.add_argument('--group-by',
                        dest='group_by',
                        default='cgroup',
                        choices=['cgroup', 'attribute'],
                        required=False,
                        help='how cgroup attribute columns shall be grouped (default: cgroup')  
    parser.add_argument('controller',
                        metavar='CONTROLLER',
                        type=str,
                        choices=supported,
                        help='extract data for this cgroup controller')
    parser.add_argument('cgroups', 
                        metavar='CGROUP',
                        nargs='+',
                        type=str,
                        help='extract data for this cgroup'),

    args = parser.parse_args()

    # Convert times into datetime objects
    try:
        args.time_range = (
            datetime.datetime.strptime(args.start_time, '%Y-%m-%dT%H:%M:%S') if args.start_time else None,
            datetime.datetime.strptime(args.end_time, '%Y-%m-%dT%H:%M:%S') if args.end_time else None)
    except Exception as err:
        print(f'Error in time range: {err}')
        sys.exit(1)  

    # Check that only valid attributes are listed for the filter
    # and set the attributes we want to extract.
    if args.filter:
        if set(args.filter) - supported[args.controller]:
            print(f'''Unsupported filter found! Only supported are: {', '.join(supported[args.controller])}''')
            sys.exit(0)     
        args.attributes = set(args.filter)
    else:
        args.attributes = supported[args.controller]

    # Check if the logfile is available.
    if not os.path.isfile(args.logfile) and os.access(args.logfile):
        print(f'Logfile "{args.logfile}" does not exists!')
        sys.exit(0)     

    return args


def convert(attr: str, value: str) -> dict:
    """Takes a cgroup attribute value pair and returns a dict
    with the attribute columns and normalized values."""

    try:
        if attr in ['memory.current', 'memory.swap.current']:
            return { attr : int(value) } 
        elif attr == 'memory.pressure':
            # some avg10=0.00 avg60=0.00 avg300=0.00 total=0
            # full avg10=0.00 avg60=0.00 avg300=0.00 total=0
            some, full = value.split('\n')
            some_comp = some.split()
            full_comp = some.split()
            return {f'{attr}::some_avg10': float(some_comp[1].split('=')[1]),
                    f'{attr}::some_avg60': float(some_comp[2].split('=')[1]),
                    f'{attr}::some_avg300': float(some_comp[3].split('=')[1]),
                    f'{attr}::some_total': float(some_comp[4].split('=')[1]),
                    f'{attr}::full_avg10': float(full_comp[1].split('=')[1]),
                    f'{attr}::full_avg60': float(full_comp[2].split('=')[1]),
                    f'{attr}::full_avg300': float(full_comp[3].split('=')[1]),
                    f'{attr}::full_total': float(full_comp[4].split('=')[1])
                   }
        else:
            print(f'Conversion of cgroup attribute found unknown attribute: {attr}', file=sys.stderr)           
    except Exception as err:
        print(f'Conversion of cgroup attribute value "{attr} = {value}" failed: {err}', file=sys.stderr)
        return None


def print_csv(cols: list, separator: str = ',', quote_string : bool = True) -> None:
    """Prints list as CSV row."""

    cols_transformed = []

    # Transform certain data types.
    for col in cols:
        if quote_string and isinstance(col, str):
            cols_transformed.append(f'"{col}"')   # surround strings with quotes
        else:
            cols_transformed.append(str(col))     
    print(separator.join(cols_transformed))


def main():

    # Parse command line arguments.
    arguments = argument_parse()

    try: 
        with open(arguments.logfile, 'r') as f:
            
            attrib2header = {attrib: attrib_resolved for controller_files in ATTRIBUTE_MAP.values() for attrib, attrib_resolved in controller_files.items()}
            
            # Build ordered headers.
            attributes_resolved = [item for sublist in [attrib2header[attr] for attr in arguments.attributes] for item in sublist]
            if arguments.group_by == 'attribute':
                headers =[(cg, attrib) for attrib in attributes_resolved for cg in arguments.cgroups]
            else:
                headers =[(cg, attrib) for cg in arguments.cgroups for attrib in attributes_resolved]

            # Print the CSV header first.
            print_csv(['timestamp'] + ['::'.join(h) for h in headers], separator=arguments.separator, quote_string=arguments.quotestrings)

            # Iterate over log (one JSON object each line).
            for line in f:
                
                # Usually each line has only one timestamp and dataset, but
                # maybe this will change.
                for timestamp, dataset in json.loads(line).items():
                
                    # Check if entry is in given time range.
                    timestamp_short = datetime.datetime.strptime(timestamp[:19], '%Y-%m-%dT%H:%M:%S')
                    if arguments.time_range[0] and timestamp_short < arguments.time_range[0]:
                        continue
                    if arguments.time_range[1] and timestamp_short > arguments.time_range[1]:
                        continue

                    # ! Works, but the header still contain regex! They need expansion too. :-/
                    # # Expand cgroup arguments (regex) with current dataset.
                    # expanded_cgroups = []
                    # for cgroup in arguments.cgroups:
                    #     expanded_cgroups.extend([cg for cg in dataset.keys() if re.search(cgroup, cg)])
                    
                    cgroup_data = {}
                    for cgroup in arguments.cgroups:
                    #for cgroup in expanded_cgroups:    # ! for a time when regex expansion works
   
                        cgroup_data[cgroup] = {}

                        # Skip if the requested cgroup is not in the data set.
                        # ! Do we need this after we expanded argument with dataset?
                        if cgroup not in dataset:
                            print(f'Cgroup "{cgroup}" not in this data set.')
                            continue 
                        
                        # Extract the attributes we want.
                        for attribute in arguments.attributes:
                            cgroup_data[cgroup].update(convert(attribute, dataset[cgroup][attribute]))
                    
                    # Print a value row.    
                    row = [timestamp]
                    for cg, attrib in headers:
                        if attrib in cgroup_data[cg]: 
                            row.append(cgroup_data[cg][attrib])
                        else:
                            row.append('-')   # attribute not found in current dataset
                    print_csv(row, separator=arguments.separator, quote_string=arguments.quotestrings)
                
    except BrokenPipeError:
        # Handle BrokenPipe issue: https://docs.python.org/3/library/signal.html#note-on-sigpipe
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        sys.exit(0)

    except Exception as err:
        print(f'Sadly a runtime error ocurred: {err}')
        sys.exit(3)  

    # Bye.        
    sys.exit(0)


if __name__ == "__main__":
    main()